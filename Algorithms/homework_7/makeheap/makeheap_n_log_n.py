def parent(i):
    return (i - 1) // 2

def sift_up(heap, i):
    # тут если мы верим что куча у нас
    # то для любого объекта с индексом i левый сын: 2i+1; правый 2i+2
    # следовательно родитель будет (i-1) // 2 (для iой вершины)
    while i > 0 and heap[i] < heap[parent(i)]: # <= log(n) - высота
        heap[i], heap[parent(i)] = heap[parent(i)], heap[i]
        # достаточно проверить только одного сына, так как по правилам построения старый родитель был <= брата
        i = parent(i)


def makeheap_n_log_n(arr):
    heap = []

    for x in arr:
        heap.append(x)
        # основное свойство кучи - элемент >= чем родитель
        sift_up(heap, len(heap)-1) # тут мы ровно это пытаемся исправить

    return heap

# тут довольно понятная логика почему это будет работать на добавление
# тогда легко можно понять, что если мы создаем массив каждый раз по логике sift, то поддерживаем кучу при построении
